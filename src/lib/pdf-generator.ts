import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import { CrawlResult } from "./crawler";
import { ScanResult } from "./scanner";

const BRAND = "AI Recon System";
const addFooter = (doc: jsPDF) => {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(120);
    doc.text(`Generated by ${BRAND} — ${new Date().toISOString()}`, 14, doc.internal.pageSize.height - 10);
    doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 40, doc.internal.pageSize.height - 10);
  }
};

export const generateCrawlPDF = (result: CrawlResult) => {
  const doc = new jsPDF();
  const w = doc.internal.pageSize.width;

  // Title page
  doc.setFillColor(10, 14, 26);
  doc.rect(0, 0, w, doc.internal.pageSize.height, "F");
  doc.setTextColor(0, 255, 136);
  doc.setFontSize(28);
  doc.text("AI Web Crawler Report", w / 2, 80, { align: "center" });
  doc.setFontSize(14);
  doc.setTextColor(180);
  doc.text(result.main_domain, w / 2, 100, { align: "center" });
  doc.setFontSize(10);
  doc.text(new Date().toLocaleString(), w / 2, 115, { align: "center" });
  doc.text(`Crawl Duration: ${result.crawl_time}`, w / 2, 125, { align: "center" });
  if (result.stopped_early) {
    doc.setTextColor(255, 200, 0);
    doc.text("⚠ Crawl was stopped early by user", w / 2, 140, { align: "center" });
  }

  // Executive Summary
  doc.addPage();
  doc.setTextColor(40);
  doc.setFontSize(20);
  doc.text("Executive Summary", 14, 30);
  doc.setFontSize(11);
  doc.setTextColor(80);

  const summary = [
    ["Total Pages Crawled", String(result.pages_crawled)],
    ["Internal Links", String(result.internal_links.length)],
    ["External Links", String(result.external_links.length)],
    ["Subdomains Found", String(result.subdomains.length)],
    ["Stopped Early", result.stopped_early ? "Yes" : "No"],
    ["Crawl Duration", result.crawl_time],
  ];

  autoTable(doc, {
    startY: 40,
    head: [["Metric", "Value"]],
    body: summary,
    theme: "striped",
    headStyles: { fillColor: [0, 180, 100] },
  });

  // Internal Links
  doc.addPage();
  doc.setFontSize(16);
  doc.setTextColor(40);
  doc.text("Internal Links", 14, 20);

  autoTable(doc, {
    startY: 30,
    head: [["#", "URL"]],
    body: result.internal_links.map((link, i) => [String(i + 1), link]),
    theme: "grid",
    headStyles: { fillColor: [0, 150, 90] },
    styles: { fontSize: 8 },
  });

  // External Links
  doc.addPage();
  doc.setFontSize(16);
  doc.text("External Links", 14, 20);

  autoTable(doc, {
    startY: 30,
    head: [["#", "URL"]],
    body: result.external_links.map((link, i) => [String(i + 1), link]),
    theme: "grid",
    headStyles: { fillColor: [0, 130, 180] },
    styles: { fontSize: 8 },
  });

  // Subdomains
  if (result.subdomains.length > 0) {
    doc.addPage();
    doc.setFontSize(16);
    doc.text("Subdomains", 14, 20);
    autoTable(doc, {
      startY: 30,
      head: [["#", "Subdomain"]],
      body: result.subdomains.map((s, i) => [String(i + 1), s]),
      theme: "grid",
      headStyles: { fillColor: [100, 60, 180] },
      styles: { fontSize: 9 },
    });
  }

  // Attack Surface Analysis
  if (result.crawled_pages && result.crawled_pages.length > 0) {
    doc.addPage();
    doc.setFontSize(16);
    doc.setTextColor(40);
    doc.text("Attack Surface Analysis", 14, 20);
    autoTable(doc, {
      startY: 30,
      head: [["URL", "Status", "Links", "Attack Vectors"]],
      body: result.crawled_pages.map((p) => [
        p.url.substring(0, 60), String(p.status), String(p.links_found),
        p.attack_surface.join("; ") || "None detected",
      ]),
      theme: "grid",
      headStyles: { fillColor: [200, 100, 0] },
      styles: { fontSize: 7, cellPadding: 2 },
      columnStyles: { 0: { cellWidth: 55 }, 3: { cellWidth: 70 } },
    });
  }

  addFooter(doc);
  doc.save(`crawler-report-${Date.now()}.pdf`);
};

export const generateScanPDF = (result: ScanResult) => {
  const doc = new jsPDF();
  const w = doc.internal.pageSize.width;

  // Cover Page
  doc.setFillColor(10, 14, 26);
  doc.rect(0, 0, w, doc.internal.pageSize.height, "F");
  doc.setTextColor(0, 212, 255);
  doc.setFontSize(26);
  doc.text("Vulnerability Assessment Report", w / 2, 80, { align: "center" });
  doc.setFontSize(14);
  doc.setTextColor(180);
  doc.text(result.target, w / 2, 100, { align: "center" });
  doc.setFontSize(10);
  doc.text(new Date().toLocaleString(), w / 2, 115, { align: "center" });

  const riskColor: Record<string, [number, number, number]> = {
    Low: [0, 200, 100],
    Medium: [255, 200, 0],
    High: [255, 140, 0],
    Critical: [255, 60, 60],
  };
  const rc = riskColor[result.risk_score] || [180, 180, 180];
  doc.setTextColor(rc[0], rc[1], rc[2]);
  doc.setFontSize(18);
  doc.text(`Risk Score: ${result.risk_score}`, w / 2, 140, { align: "center" });

  // Executive Summary
  doc.addPage();
  doc.setTextColor(40);
  doc.setFontSize(20);
  doc.text("Executive Summary", 14, 30);

  const counts = { low: 0, medium: 0, high: 0, critical: 0 };
  result.vulnerabilities_found.forEach((v) => counts[v.severity]++);

  autoTable(doc, {
    startY: 40,
    head: [["Metric", "Value"]],
    body: [
      ["Total Vulnerabilities", String(result.vulnerabilities_found.length)],
      ["Critical", String(counts.critical)],
      ["High", String(counts.high)],
      ["Medium", String(counts.medium)],
      ["Low", String(counts.low)],
      ["Risk Score", result.risk_score],
      ["Scan Duration", result.scan_time],
    ],
    theme: "striped",
    headStyles: { fillColor: [0, 150, 200] },
  });

  // Vulnerability Breakdown
  if (result.vulnerabilities_found.length > 0) {
    doc.addPage();
    doc.setFontSize(16);
    doc.setTextColor(40);
    doc.text("Vulnerability Breakdown", 14, 20);

    autoTable(doc, {
      startY: 30,
      head: [["Type", "Severity", "Description", "Evidence", "Recommendation"]],
      body: result.vulnerabilities_found.map((v) => [
        v.type, v.severity.toUpperCase(), v.description, v.evidence, v.recommendation,
      ]),
      theme: "grid",
      headStyles: { fillColor: [200, 50, 50] },
      styles: { fontSize: 7, cellPadding: 3 },
      columnStyles: {
        0: { cellWidth: 30 },
        1: { cellWidth: 18 },
        2: { cellWidth: 45 },
        3: { cellWidth: 45 },
        4: { cellWidth: 45 },
      },
    });
  }

  // Security Headers
  doc.addPage();
  doc.setFontSize(16);
  doc.setTextColor(40);
  doc.text("Security Headers Analysis", 14, 20);

  autoTable(doc, {
    startY: 30,
    head: [["Header", "Value", "Status"]],
    body: Object.entries(result.security_headers).map(([h, v]) => [
      h, v, v === "Not Set" ? "⚠ Missing" : "✓ Present",
    ]),
    theme: "striped",
    headStyles: { fillColor: [60, 60, 60] },
    styles: { fontSize: 9 },
  });

  // Remediation Guidance
  doc.addPage();
  doc.setFontSize(16);
  doc.text("Remediation Guidance", 14, 20);
  doc.setFontSize(10);
  doc.setTextColor(80);

  let y = 35;
  result.vulnerabilities_found.forEach((v, i) => {
    if (y > 260) { doc.addPage(); y = 20; }
    doc.setFontSize(11);
    doc.setTextColor(40);
    doc.text(`${i + 1}. ${v.type} [${v.severity.toUpperCase()}]`, 14, y);
    y += 7;
    doc.setFontSize(9);
    doc.setTextColor(80);
    const lines = doc.splitTextToSize(v.recommendation, w - 28);
    doc.text(lines, 14, y);
    y += lines.length * 5 + 8;
  });

  addFooter(doc);
  doc.save(`vulnerability-report-${Date.now()}.pdf`);
};
