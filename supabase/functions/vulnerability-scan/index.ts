import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
};

interface Vulnerability {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  description: string;
  evidence: string;
  recommendation: string;
}

const UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";

async function safeFetch(url: string, opts: RequestInit & { timeout?: number } = {}): Promise<Response | null> {
  try {
    const { timeout = 6000, ...fetchOpts } = opts;
    return await fetch(url, { ...fetchOpts, signal: AbortSignal.timeout(timeout) });
  } catch {
    return null;
  }
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const { url } = await req.json();
    if (!url) {
      return new Response(JSON.stringify({ error: "URL is required" }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const target = url.startsWith("http") ? url : `https://${url}`;
    const vulnerabilities: Vulnerability[] = [];
    const securityHeaders: Record<string, string> = {};
    const steps: string[] = [];

    steps.push(`[*] Initializing vulnerability scan engine for ${target}`);
    steps.push(`[*] Loading attack signature database...`);

    // 1. Fetch the target URL with retry
    let response: Response;
    let body: string;
    steps.push(`[+] Connecting to target: ${target}`);
    
    const fetchAttempts = [
      { headers: { "User-Agent": UA, "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "en-US,en;q=0.5", "Accept-Encoding": "identity", "Connection": "keep-alive" }, timeout: 20000 },
      { headers: { "User-Agent": "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)" }, timeout: 20000 },
    ];
    
    let fetchSuccess = false;
    let lastError = "";
    for (const attempt of fetchAttempts) {
      try {
        response = await fetch(target, {
          method: "GET",
          redirect: "follow",
          headers: attempt.headers,
          signal: AbortSignal.timeout(attempt.timeout),
        });
        body = await response.text();
        steps.push(`[✓] Connection established — HTTP ${response.status!}`);
        steps.push(`[+] Response size: ${body.length} bytes`);
        fetchSuccess = true;
        break;
      } catch (e) {
        lastError = e instanceof Error ? e.message : "Unknown error";
        steps.push(`[!] Connection attempt failed: ${lastError}, retrying...`);
      }
    }
    
    if (!fetchSuccess) {
      return new Response(
        JSON.stringify({
          error: `Could not reach target after retries: ${lastError}. The site may be blocking automated requests or is unreachable from our servers.`,
        }),
        { status: 502, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const headers = response.headers;

    // ========== SECURITY HEADER CHECKS (Phase 1) ==========
    steps.push(`\n[*] === Phase 1: Security Header Analysis ===`);
    const headerChecks = [
      { header: "content-security-policy", label: "Missing Content-Security-Policy", severity: "medium" as const, recommendation: "Implement a strict CSP header to prevent XSS attacks." },
      { header: "x-frame-options", label: "Missing X-Frame-Options", severity: "medium" as const, recommendation: "Add X-Frame-Options: DENY or SAMEORIGIN to prevent clickjacking." },
      { header: "strict-transport-security", label: "Missing Strict-Transport-Security", severity: "low" as const, recommendation: "Add HSTS header with max-age=31536000." },
      { header: "x-content-type-options", label: "Missing X-Content-Type-Options", severity: "low" as const, recommendation: "Add X-Content-Type-Options: nosniff." },
      { header: "x-xss-protection", label: "Missing X-XSS-Protection", severity: "low" as const, recommendation: "Add X-XSS-Protection: 1; mode=block." },
      { header: "referrer-policy", label: "Missing Referrer-Policy", severity: "low" as const, recommendation: "Add Referrer-Policy: strict-origin-when-cross-origin." },
      { header: "permissions-policy", label: "Missing Permissions-Policy", severity: "low" as const, recommendation: "Add Permissions-Policy header." },
    ];

    for (const check of headerChecks) {
      const value = headers.get(check.header);
      securityHeaders[check.header] = value || "Not Set";
      if (!value) {
        vulnerabilities.push({ type: check.label, severity: check.severity, description: `The ${check.header} header is not set.`, evidence: `Header '${check.header}' absent`, recommendation: check.recommendation });
        steps.push(`[!] ${check.label}`);
      } else {
        steps.push(`[✓] ${check.header}: ${value.substring(0, 80)}`);
      }
    }

    // ========== CORS (Phase 2) ==========
    steps.push(`\n[*] === Phase 2: CORS Configuration ===`);
    const acao = headers.get("access-control-allow-origin");
    securityHeaders["access-control-allow-origin"] = acao || "Not Set";
    if (acao === "*") {
      vulnerabilities.push({ type: "CORS Misconfiguration", severity: "medium", description: "Access-Control-Allow-Origin is wildcard (*).", evidence: "ACAO: *", recommendation: "Restrict CORS to trusted domains." });
      steps.push(`[!] CORS wildcard (*) detected`);
    } else {
      steps.push(`[✓] CORS: ${acao || "Not Set (restricted)"}`);
    }

    // ========== HTTPS (Phase 3) ==========
    steps.push(`\n[*] === Phase 3: Transport Layer Security ===`);
    if (target.startsWith("http://")) {
      vulnerabilities.push({ type: "Missing HTTPS", severity: "high", description: "Site accessed over plain HTTP.", evidence: `URL: ${target}`, recommendation: "Enforce HTTPS with a valid TLS certificate." });
      steps.push(`[!] Site uses unencrypted HTTP`);
    } else {
      steps.push(`[✓] HTTPS enforced`);
    }

    // ========== SERVER INFO (Phase 4) ==========
    steps.push(`\n[*] === Phase 4: Information Disclosure ===`);
    const serverHeader = headers.get("server");
    const poweredBy = headers.get("x-powered-by");
    if (serverHeader) {
      securityHeaders["server"] = serverHeader;
      if (/\d+\.\d+/.test(serverHeader)) {
        vulnerabilities.push({ type: "Server Version Disclosure", severity: "low", description: "Server header reveals version.", evidence: `Server: ${serverHeader}`, recommendation: "Remove version from Server header." });
        steps.push(`[!] Server version disclosed: ${serverHeader}`);
      }
    }
    if (poweredBy) {
      securityHeaders["x-powered-by"] = poweredBy;
      vulnerabilities.push({ type: "Technology Disclosure", severity: "low", description: "X-Powered-By reveals technology stack.", evidence: `X-Powered-By: ${poweredBy}`, recommendation: "Remove X-Powered-By header." });
      steps.push(`[!] X-Powered-By: ${poweredBy}`);
    }

    // ========== EXTRACT LINKS & FORMS (for later phases) ==========
    const urlsWithParams = new Set<string>();
    const linkMatches = body.match(/(?:href|action|src)\s*=\s*["']([^"']*\?[^"']+)["']/gi) || [];
    for (const match of linkMatches) {
      const urlMatch = match.match(/["']([^"']+)["']/);
      if (urlMatch) urlsWithParams.add(urlMatch[1]);
    }

    const allLinks = body.match(/(?:href|src|action)\s*=\s*["']([^"']+)["']/gi) || [];
    const endpoints = new Set<string>();
    const externalDomains = new Set<string>();
    for (const match of allLinks) {
      const urlMatch = match.match(/["']([^"']+)["']/);
      if (urlMatch) {
        try {
          const parsed = new URL(urlMatch[1], target);
          if (parsed.origin === new URL(target).origin) endpoints.add(parsed.pathname);
          else if (parsed.protocol.startsWith("http")) externalDomains.add(parsed.hostname);
        } catch { /* skip */ }
      }
    }

    // ========== PARALLEL PROBES: SQLi, XSS, DirTraversal, Recon ==========
    // We run all secondary network calls in parallel to stay within time limits

    const paramUrls = Array.from(urlsWithParams).slice(0, 2);
    const sensitivePaths = ["/.env", "/.git/config", "/admin", "/phpinfo.php", "/.htaccess", "/.DS_Store"];
    const hostname = new URL(target).hostname;

    // Build all probe promises
    const sqliProbes = paramUrls.map(async (paramUrl) => {
      try {
        const fullUrl = paramUrl.startsWith("http") ? paramUrl : new URL(paramUrl, target).href;
        const testUrl = fullUrl.replace(/=([^&]+)/, "=$1'");
        const resp = await safeFetch(testUrl, { headers: { "User-Agent": UA } });
        if (!resp) return null;
        const testBody = await resp.text();
        const sqlErrors = [/sql syntax/i, /mysql_fetch/i, /ORA-\d+/i, /PostgreSQL.*ERROR/i, /ODBC/i, /sqlite/i, /unterminated quoted string/i, /syntax error at or near/i];
        for (const pattern of sqlErrors) {
          if (pattern.test(testBody)) return { url: testUrl, pattern: pattern.source };
        }
      } catch { /* skip */ }
      return null;
    });

    const xssProbe = "lvbl" + Math.floor(Math.random() * 10000);
    const xssProbes = paramUrls.map(async (paramUrl) => {
      try {
        const fullUrl = paramUrl.startsWith("http") ? paramUrl : new URL(paramUrl, target).href;
        const testUrl = fullUrl.replace(/=([^&]+)/, `=${xssProbe}<script>`);
        const resp = await safeFetch(testUrl, { headers: { "User-Agent": UA } });
        if (!resp) return null;
        const testBody = await resp.text();
        if (testBody.includes(`${xssProbe}<script>`)) return fullUrl;
      } catch { /* skip */ }
      return null;
    });

    const dirProbes = sensitivePaths.map(async (path) => {
      const testUrl = target.replace(/\/$/, "") + path;
      const resp = await safeFetch(testUrl, { method: "HEAD", headers: { "User-Agent": UA }, redirect: "manual" as RequestRedirect });
      if (resp && resp.status === 200) return path;
      return null;
    });

    const dnsProbe = (async () => {
      try {
        const resp = await safeFetch(`https://dns.google/resolve?name=${hostname}&type=A`, { timeout: 5000 });
        if (!resp) return [];
        const data = await resp.json();
        return (data.Answer || []).filter((a: any) => a.type === 1).map((a: any) => a.data);
      } catch { return []; }
    })();

    // Run all probes in parallel
    const [sqliResults, xssResults, dirResults, ipAddresses] = await Promise.all([
      Promise.all(sqliProbes),
      Promise.all(xssProbes),
      Promise.all(dirProbes),
      dnsProbe,
    ]);

    // Process SQLi results
    steps.push(`\n[*] === Phase 5: SQL Injection Detection ===`);
    const sqliHits = sqliResults.filter(Boolean);
    if (sqliHits.length > 0) {
      for (const hit of sqliHits) {
        vulnerabilities.push({ type: "Potential SQL Injection", severity: "critical", description: "SQL error messages returned on injection probe.", evidence: `Pattern: ${hit!.pattern}`, recommendation: "Use parameterized queries." });
        steps.push(`[!] CRITICAL: SQL injection detected`);
      }
    } else {
      steps.push(`[✓] No SQL injection patterns detected`);
    }

    // Process XSS results
    steps.push(`\n[*] === Phase 6: XSS Detection ===`);
    const xssHits = xssResults.filter(Boolean);
    if (xssHits.length > 0) {
      for (const hit of xssHits) {
        vulnerabilities.push({ type: "Reflected XSS", severity: "high", description: "Input reflected without encoding.", evidence: `URL: ${String(hit).substring(0, 100)}`, recommendation: "Encode all user input. Implement CSP." });
        steps.push(`[!] Reflected XSS detected`);
      }
    }

    // DOM XSS sinks (no network, just body scan)
    const domXssSinks = [/\.innerHTML\s*=/, /document\.write\s*\(/, /eval\s*\(/];
    let domXssCount = 0;
    for (const sink of domXssSinks) {
      const m = body.match(sink);
      if (m) domXssCount += m.length;
    }
    if (domXssCount > 3) {
      vulnerabilities.push({ type: "DOM XSS Sinks", severity: "medium", description: `${domXssCount} dangerous DOM patterns found.`, evidence: `innerHTML/eval patterns`, recommendation: "Use textContent instead of innerHTML." });
    }
    if (xssHits.length === 0 && domXssCount <= 3) steps.push(`[✓] No XSS vulnerabilities detected`);

    // Process directory traversal
    steps.push(`\n[*] === Phase 7: Sensitive File Exposure ===`);
    const dirHits = dirResults.filter(Boolean);
    if (dirHits.length > 0) {
      for (const path of dirHits) {
        const isSensitive = ["/.env", "/.git/config", "/.htaccess", "/.DS_Store"].includes(path!);
        vulnerabilities.push({
          type: isSensitive ? "Sensitive File Exposure" : "Admin Endpoint Exposed",
          severity: isSensitive ? "high" : "medium",
          description: `${path} is publicly accessible.`,
          evidence: `HTTP 200 for ${path}`,
          recommendation: "Block access to sensitive files.",
        });
        steps.push(`[!] ${isSensitive ? "HIGH" : "MEDIUM"}: ${path} accessible`);
      }
    } else {
      steps.push(`[✓] No sensitive files exposed`);
    }

    // ========== BODY-ONLY ANALYSIS (no network) ==========

    // Phase 8: Open Redirect
    steps.push(`\n[*] === Phase 8: Open Redirect Detection ===`);
    const redirectParams = body.match(/(?:redirect|return|next|url|goto|dest)\s*=\s*["']?([^"'\s&>]+)/gi) || [];
    if (redirectParams.some((p) => /https?:\/\//.test(p))) {
      vulnerabilities.push({ type: "Potential Open Redirect", severity: "medium", description: "Redirect parameters point to external URLs.", evidence: `${redirectParams.length} redirect params`, recommendation: "Validate redirects against whitelist." });
      steps.push(`[!] Open redirect patterns found`);
    } else {
      steps.push(`[✓] No open redirect patterns`);
    }

    // Phase 9: Inline Scripts
    steps.push(`\n[*] === Phase 9: Content Security ===`);
    const inlineScripts = (body.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || []).filter((s) => !s.includes("src="));
    if (inlineScripts.length > 5 && !headers.get("content-security-policy")) {
      vulnerabilities.push({ type: "Excessive Inline Scripts without CSP", severity: "medium", description: `${inlineScripts.length} inline scripts without CSP.`, evidence: `${inlineScripts.length} inline <script> tags`, recommendation: "Implement CSP and externalize scripts." });
    }

    // Phase 10: CSRF
    steps.push(`\n[*] === Phase 10: CSRF Protection ===`);
    const forms = body.match(/<form[^>]*>/gi) || [];
    if (forms.length > 0 && !/csrf|_token|authenticity_token/i.test(body)) {
      vulnerabilities.push({ type: "Missing CSRF Protection", severity: "medium", description: `${forms.length} forms without CSRF tokens.`, evidence: `No CSRF fields`, recommendation: "Add CSRF tokens to all forms." });
      steps.push(`[!] Forms without CSRF protection`);
    }

    // Phase 11: Mixed Content
    if (target.startsWith("https://")) {
      const httpRes = body.match(/(?:src|href)\s*=\s*["']http:\/\/[^"']+["']/gi) || [];
      if (httpRes.length > 0) {
        vulnerabilities.push({ type: "Mixed Content", severity: "medium", description: `${httpRes.length} HTTP resources on HTTPS page.`, evidence: httpRes[0]?.substring(0, 100) || "", recommendation: "Load all resources over HTTPS." });
      }
    }

    // Phase 12: Cookies
    steps.push(`\n[*] === Phase 12: Cookie Security ===`);
    const setCookie = headers.get("set-cookie");
    if (setCookie) {
      if (!setCookie.toLowerCase().includes("secure")) vulnerabilities.push({ type: "Insecure Cookie", severity: "medium", description: "Cookie missing Secure flag.", evidence: "Set-Cookie without Secure", recommendation: "Add Secure flag." });
      if (!setCookie.toLowerCase().includes("httponly")) vulnerabilities.push({ type: "Cookie Missing HttpOnly", severity: "medium", description: "Cookie accessible to JavaScript.", evidence: "Set-Cookie without HttpOnly", recommendation: "Add HttpOnly flag." });
    }

    // Phase 13: Tech fingerprinting (headers only, no CVE probing)
    steps.push(`\n[*] === Phase 13: Technology Fingerprinting ===`);
    const techPatterns = [
      /wp-content|wordpress/i, /drupal/i, /joomla/i, /shopify/i, /react/i, /vue/i, /angular|ng-version/i,
      /next\.?js|__next/i, /jquery/i, /bootstrap/i, /tailwind/i, /php/i, /asp\.net|__VIEWSTATE/i,
      /django/i, /laravel/i, /ruby.*rails/i, /phpmyadmin/i,
    ];
    const techNames: Record<string, string> = {
      "wp-content|wordpress": "WordPress", "drupal": "Drupal", "joomla": "Joomla", "shopify": "Shopify",
      "react": "React", "vue": "Vue.js", "angular|ng-version": "Angular", "next\\.?js|__next": "Next.js",
      "jquery": "jQuery", "bootstrap": "Bootstrap", "tailwind": "Tailwind CSS", "php": "PHP",
      "asp\\.net|__VIEWSTATE": "ASP.NET", "django": "Django", "laravel": "Laravel", "ruby.*rails": "Ruby on Rails",
      "phpmyadmin": "phpMyAdmin",
    };
    if (body.match(/phpmyadmin/i)) {
      vulnerabilities.push({ type: "Exposed Database Admin Panel", severity: "critical", description: "phpMyAdmin is publicly accessible.", evidence: "phpMyAdmin signature", recommendation: "Restrict to internal networks." });
    }

    // ========== RECON INTEL (Phase 15) ==========
    steps.push(`\n[*] === Phase 15: Reconnaissance Intelligence ===`);
    const reconIntel: Record<string, any> = {};

    // IP
    reconIntel.ip_addresses = ipAddresses.length > 0 ? ipAddresses : ["Could not resolve"];
    steps.push(`[✓] IP: ${reconIntel.ip_addresses.join(", ")}`);

    // Geo + SSL in parallel
    const [geoResult, sslResult] = await Promise.all([
      (async () => {
        if (ipAddresses.length === 0) return null;
        try {
          const resp = await safeFetch(`http://ip-api.com/json/${ipAddresses[0]}?fields=status,country,regionName,city,isp,org,as,lat,lon`, { timeout: 5000 });
          if (!resp) return null;
          const d = await resp.json();
          if (d.status === "success") return { country: d.country, region: d.regionName, city: d.city, isp: d.isp, org: d.org, as_number: d.as, lat: d.lat, lon: d.lon };
        } catch { /* skip */ }
        return null;
      })(),
      (async () => {
        if (!target.startsWith("https://")) return { issuer: "No SSL/TLS", subject: "HTTP only" };
        try {
          const resp = await safeFetch(`https://ssl-checker.io/api/v1/check/${hostname}`, { timeout: 6000 });
          if (resp?.ok) {
            const d = await resp.json();
            return { issuer: d.issuer || d.result?.issuer || "Unknown", subject: d.subject || d.result?.subject || hostname, valid_from: d.valid_from || d.result?.valid_from, valid_to: d.valid_to || d.result?.valid_to, protocol: d.protocol || "TLS" };
          }
        } catch { /* skip */ }
        return { issuer: "HTTPS Enabled", subject: hostname };
      })(),
    ]);

    if (geoResult) {
      reconIntel.geolocation = geoResult;
      steps.push(`[✓] Location: ${geoResult.city}, ${geoResult.region}, ${geoResult.country}`);
      steps.push(`[✓] ISP: ${geoResult.isp}`);
    }
    reconIntel.ssl_certificate = sslResult;
    steps.push(`[✓] SSL: ${sslResult?.issuer || "Unknown"}`);

    // Technologies
    const detectedTech: string[] = [];
    const techDb = [
      { pattern: /react/i, name: "React" }, { pattern: /vue\.?js|__vue/i, name: "Vue.js" },
      { pattern: /angular|ng-version/i, name: "Angular" }, { pattern: /next\.?js|__next/i, name: "Next.js" },
      { pattern: /jquery/i, name: "jQuery" }, { pattern: /bootstrap/i, name: "Bootstrap" },
      { pattern: /tailwind/i, name: "Tailwind CSS" }, { pattern: /wp-content|wordpress/i, name: "WordPress" },
      { pattern: /drupal/i, name: "Drupal" }, { pattern: /shopify/i, name: "Shopify" },
      { pattern: /wix\.com/i, name: "Wix" }, { pattern: /squarespace/i, name: "Squarespace" },
      { pattern: /\.php|php\//i, name: "PHP" }, { pattern: /\.aspx?|__VIEWSTATE/i, name: "ASP.NET" },
      { pattern: /django/i, name: "Django" }, { pattern: /laravel/i, name: "Laravel" },
      { pattern: /mysql|mariadb/i, name: "MySQL" }, { pattern: /postgresql|postgres/i, name: "PostgreSQL" },
      { pattern: /mongodb/i, name: "MongoDB" }, { pattern: /nginx/i, name: "Nginx" },
      { pattern: /apache/i, name: "Apache" }, { pattern: /cloudflare/i, name: "Cloudflare" },
      { pattern: /vercel/i, name: "Vercel" }, { pattern: /netlify/i, name: "Netlify" },
      { pattern: /amazonaws|aws/i, name: "AWS" }, { pattern: /google.*cloud|gstatic/i, name: "Google Cloud" },
    ];
    const fullText = body + " " + (serverHeader || "") + " " + (poweredBy || "");
    for (const t of techDb) {
      if (t.pattern.test(fullText)) detectedTech.push(t.name);
    }
    if (headers.get("cf-ray") && !detectedTech.includes("Cloudflare")) detectedTech.push("Cloudflare");
    if (headers.get("x-vercel-id") && !detectedTech.includes("Vercel")) detectedTech.push("Vercel");
    reconIntel.technologies = detectedTech.length > 0 ? detectedTech : ["No technologies fingerprinted"];
    for (const t of detectedTech) steps.push(`[✓] Detected: ${t}`);

    // Technical summary
    reconIntel.technical = {
      http_status: response.status,
      content_type: headers.get("content-type") || "Unknown",
      content_length: headers.get("content-length") || String(body.length) + " (body)",
      response_time: "Real-time",
      redirected: response.redirected,
      final_url: response.url,
      protocol: target.startsWith("https") ? "HTTPS" : "HTTP",
      internal_endpoints: endpoints.size,
      external_domains: externalDomains.size,
    };

    // ========== RISK SCORE ==========
    const riskScore = vulnerabilities.some((v) => v.severity === "critical") ? "Critical"
      : vulnerabilities.some((v) => v.severity === "high") ? "High"
      : vulnerabilities.some((v) => v.severity === "medium") ? "Medium" : "Low";

    steps.push(`\n[*] === Scan Complete ===`);
    steps.push(`[+] Vulnerabilities: ${vulnerabilities.length}`);
    steps.push(`[+] Risk Score: ${riskScore}`);

    return new Response(
      JSON.stringify({ target, scan_time: "real-time", vulnerabilities_found: vulnerabilities, security_headers: securityHeaders, risk_score: riskScore, recon_intel: reconIntel, steps }),
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (err) {
    return new Response(
      JSON.stringify({ error: err instanceof Error ? err.message : "Unknown error" }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
