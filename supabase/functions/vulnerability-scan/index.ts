import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
};

interface Vulnerability {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  description: string;
  evidence: string;
  recommendation: string;
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const { url } = await req.json();
    if (!url) {
      return new Response(JSON.stringify({ error: "URL is required" }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const target = url.startsWith("http") ? url : `https://${url}`;
    const vulnerabilities: Vulnerability[] = [];
    const securityHeaders: Record<string, string> = {};
    const steps: string[] = [];

    // 1. Fetch the target URL
    let response: Response;
    try {
      response = await fetch(target, {
        method: "GET",
        redirect: "follow",
        headers: { "User-Agent": "LovableSecurityScanner/1.0" },
        signal: AbortSignal.timeout(15000),
      });
    } catch (fetchErr) {
      return new Response(
        JSON.stringify({
          error: `Could not reach target: ${fetchErr instanceof Error ? fetchErr.message : "Unknown error"}`,
        }),
        { status: 502, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const headers = response.headers;
    const body = await response.text();

    // 2. Check security headers
    const headerChecks: { header: string; label: string; severity: "low" | "medium"; recommendation: string }[] = [
      {
        header: "content-security-policy",
        label: "Missing Content-Security-Policy",
        severity: "medium",
        recommendation: "Implement a strict CSP header to prevent inline script execution and XSS attacks.",
      },
      {
        header: "x-frame-options",
        label: "Missing X-Frame-Options",
        severity: "medium",
        recommendation: "Add X-Frame-Options: DENY or SAMEORIGIN header to prevent clickjacking.",
      },
      {
        header: "strict-transport-security",
        label: "Missing Strict-Transport-Security",
        severity: "low",
        recommendation: "Add Strict-Transport-Security: max-age=31536000; includeSubDomains header.",
      },
      {
        header: "x-content-type-options",
        label: "Missing X-Content-Type-Options",
        severity: "low",
        recommendation: "Add X-Content-Type-Options: nosniff header to prevent MIME-type sniffing.",
      },
      {
        header: "x-xss-protection",
        label: "Missing X-XSS-Protection",
        severity: "low",
        recommendation: "Add X-XSS-Protection: 1; mode=block header.",
      },
      {
        header: "referrer-policy",
        label: "Missing Referrer-Policy",
        severity: "low",
        recommendation: "Add Referrer-Policy: strict-origin-when-cross-origin header.",
      },
      {
        header: "permissions-policy",
        label: "Missing Permissions-Policy",
        severity: "low",
        recommendation: "Add a Permissions-Policy header to control browser feature access.",
      },
    ];

    for (const check of headerChecks) {
      const value = headers.get(check.header);
      securityHeaders[check.header] = value || "Not Set";
      if (!value) {
        vulnerabilities.push({
          type: check.label,
          severity: check.severity,
          description: `The ${check.header} header is not set on the server response.`,
          evidence: `Header '${check.header}' absent from HTTP response`,
          recommendation: check.recommendation,
        });
        steps.push(`[!] ${check.label} detected`);
      } else {
        steps.push(`[✓] ${check.header}: ${value}`);
      }
    }

    // 3. CORS check
    const acao = headers.get("access-control-allow-origin");
    securityHeaders["access-control-allow-origin"] = acao || "Not Set";
    if (acao === "*") {
      vulnerabilities.push({
        type: "CORS Misconfiguration",
        severity: "medium",
        description: "Access-Control-Allow-Origin is set to wildcard (*), allowing any origin.",
        evidence: "Access-Control-Allow-Origin: * in response headers",
        recommendation: "Restrict CORS to trusted domains only.",
      });
      steps.push("[!] CORS wildcard detected");
    } else {
      steps.push(`[✓] CORS: ${acao || "Not Set (OK - restricted)"}`);
    }

    // 4. HTTPS check
    if (target.startsWith("http://")) {
      vulnerabilities.push({
        type: "Missing HTTPS",
        severity: "medium",
        description: "The target is accessed over plain HTTP without encryption.",
        evidence: `URL scheme is http:// — ${target}`,
        recommendation: "Configure the server to enforce HTTPS for all traffic.",
      });
      steps.push("[!] HTTP without TLS detected");
    }

    // 5. Check for server information disclosure
    const serverHeader = headers.get("server");
    const poweredBy = headers.get("x-powered-by");
    if (serverHeader) {
      securityHeaders["server"] = serverHeader;
      // Check if it reveals version info
      if (/\d+\.\d+/.test(serverHeader)) {
        vulnerabilities.push({
          type: "Server Version Disclosure",
          severity: "low",
          description: "The Server header reveals software version information.",
          evidence: `Server: ${serverHeader}`,
          recommendation: "Remove or obfuscate the Server header version information.",
        });
        steps.push(`[!] Server version disclosed: ${serverHeader}`);
      }
    }
    if (poweredBy) {
      securityHeaders["x-powered-by"] = poweredBy;
      vulnerabilities.push({
        type: "Technology Disclosure (X-Powered-By)",
        severity: "low",
        description: "The X-Powered-By header reveals the underlying technology stack.",
        evidence: `X-Powered-By: ${poweredBy}`,
        recommendation: "Remove the X-Powered-By header to reduce information leakage.",
      });
      steps.push(`[!] X-Powered-By disclosed: ${poweredBy}`);
    }

    // 6. Check for open redirect patterns in HTML
    const redirectPatterns = body.match(/(?:href|action|src)\s*=\s*["']?\s*(?:https?:)?\/\/[^"'\s>]+/gi);
    // We just note external redirects, not flag as vuln unless suspicious

    // 7. Check for inline scripts (potential XSS surface)
    const inlineScripts = (body.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || []).filter(
      (s) => !s.includes("src=")
    );
    if (inlineScripts.length > 5 && !headers.get("content-security-policy")) {
      vulnerabilities.push({
        type: "Excessive Inline Scripts without CSP",
        severity: "medium",
        description: `Found ${inlineScripts.length} inline script blocks without a Content-Security-Policy, increasing XSS risk.`,
        evidence: `${inlineScripts.length} inline <script> tags detected in response body`,
        recommendation: "Implement a strict CSP and move inline scripts to external files.",
      });
      steps.push(`[!] ${inlineScripts.length} inline scripts without CSP`);
    }

    // 8. Check for forms without CSRF protection
    const forms = body.match(/<form[^>]*>/gi) || [];
    const formsWithoutToken = forms.filter(
      (f) => !body.includes('name="csrf') && !body.includes('name="_token') && !body.includes("csrfmiddlewaretoken")
    );
    if (formsWithoutToken.length > 0 && forms.length > 0) {
      // Only flag if we actually found forms and no CSRF tokens anywhere
      const hasCsrf = /csrf|_token|csrfmiddlewaretoken/i.test(body);
      if (!hasCsrf) {
        vulnerabilities.push({
          type: "Potential Missing CSRF Protection",
          severity: "medium",
          description: `Found ${forms.length} form(s) without apparent CSRF token protection.`,
          evidence: `No csrf/token fields detected in HTML forms`,
          recommendation: "Implement CSRF tokens in all forms to prevent cross-site request forgery.",
        });
        steps.push(`[!] Forms without CSRF protection detected`);
      }
    }

    // 9. Check for mixed content
    if (target.startsWith("https://")) {
      const httpResources = body.match(/(?:src|href|action)\s*=\s*["']http:\/\/[^"']+["']/gi) || [];
      if (httpResources.length > 0) {
        vulnerabilities.push({
          type: "Mixed Content",
          severity: "medium",
          description: `Found ${httpResources.length} HTTP resource(s) loaded on an HTTPS page.`,
          evidence: `Example: ${httpResources[0]?.substring(0, 100)}`,
          recommendation: "Ensure all resources are loaded over HTTPS to prevent mixed content warnings and MITM attacks.",
        });
        steps.push(`[!] ${httpResources.length} mixed content resources`);
      }
    }

    // 10. Cookie security check (from set-cookie headers)
    const setCookie = headers.get("set-cookie");
    if (setCookie) {
      if (!setCookie.toLowerCase().includes("secure")) {
        vulnerabilities.push({
          type: "Insecure Cookie (Missing Secure flag)",
          severity: "medium",
          description: "A cookie is set without the Secure flag.",
          evidence: `Set-Cookie header without Secure flag`,
          recommendation: "Add the Secure flag to all cookies to ensure they are only sent over HTTPS.",
        });
      }
      if (!setCookie.toLowerCase().includes("httponly")) {
        vulnerabilities.push({
          type: "Cookie Missing HttpOnly Flag",
          severity: "medium",
          description: "A cookie is set without the HttpOnly flag, making it accessible to JavaScript.",
          evidence: `Set-Cookie header without HttpOnly flag`,
          recommendation: "Add the HttpOnly flag to cookies that don't need JavaScript access.",
        });
      }
    }

    // Calculate risk score
    const riskScore = vulnerabilities.some((v) => v.severity === "critical")
      ? "Critical"
      : vulnerabilities.some((v) => v.severity === "high")
      ? "High"
      : vulnerabilities.some((v) => v.severity === "medium")
      ? "Medium"
      : "Low";

    return new Response(
      JSON.stringify({
        target,
        scan_time: "real-time",
        vulnerabilities_found: vulnerabilities,
        security_headers: securityHeaders,
        risk_score: riskScore,
        steps,
      }),
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (err) {
    return new Response(
      JSON.stringify({ error: err instanceof Error ? err.message : "Unknown error" }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
